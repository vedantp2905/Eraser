[CLS] void nlf _ down _ forward _ cpu ( const int n , const float * filters , const int channel , const int height , const int width , const int wsize , float * top _ data ) { for ( int index = 0 ; index < n ; index + + ) { int step = height * width ; int base = index * step ; int fbase = index / channel * wsize * step ; for ( int row = 0 ; row < height ; row + + ) { for ( int col = 0 ; col < width ; col + + ) { float temp = 0 ; int r = row ; int c = col ; int shift = 0 * step + row * width + col ; temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; r = row - 1 ; c = col ; shift = 1 * step + row * width + col ; if ( r > = 0 ) temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp + = top _ data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row - 1 ; c = col - 1 ; shift = 2 * step + row * width + col ; if ( r > = 0 & & c > = 0 ) temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp + = top _ data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row - 1 ; c = col + 1 ; shift = 3 * step + row * width + col ; if ( r > = 0 & & c < width ) temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp + = top _ data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row ; c = col - 1 ; shift = 4 * step + row * width + col ; if ( c > = 0 ) temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp + = top _ data [ base + row * width + col ] * filters [ fbase + shift ] ; top _ data [ base + row * width + col ] = temp ; } } } } [SEP]
[CLS] void nlf _ filter _ left _ backward _ cpu ( const int n , const float * bottom _ data , const float * top _ data , const float * temp _ diff , const int channel , const int height , const int width , const int wsize , float * filters _ diff ) { for ( int index = 0 ; index < n ; index + + ) { int step = height * width ; int base = index / step * step * channel + index % step ; int fbase = index / step * step * wsize + index % step ; int row = index % step / width ; int col = index % step % width ; for ( int i = 0 ; i < channel ; i + + ) { filters _ diff [ fbase ] + = temp _ diff [ base + i * step ] * bottom _ data [ base + i * step ] ; if ( col + 1 < width ) filters _ diff [ fbase + step ] + = temp _ diff [ base + i * step ] * top _ data [ base + 1 + i * step ] ; else filters _ diff [ fbase + step ] + = temp _ diff [ base + i * step ] * bottom _ data [ base + i * step ] ; if ( col + 1 < width & & row - 1 > = 0 ) filters _ diff [ fbase + 2 * step ] + = temp _ diff [ base + i * step ] * top _ data [ base - width + 1 + i * step ] ; else filters _ diff [ fbase + 2 * step ] + = temp _ diff [ base + i * step ] * bottom _ data [ base + i * step ] ; if ( col + 1 < width & & row + 1 < height ) filters _ diff [ fbase + 3 * step ] + = temp _ diff [ base + i * step ] * top _ data [ base + width + 1 + i * step ] ; else filters _ diff [ fbase + 3 * step ] + = temp _ diff [ base + i * step ] * bottom _ data [ base + i * step ] ; if ( row + 1 < height ) filters _ diff [ fbase + 4 * step ] + = temp _ diff [ base + i * step ] * top _ data [ base + width + i * step ] ; else filters _ diff [ fbase + 4 * step ] + = temp _ diff [ base + i * step ] * bottom _ data [ base + i * step ] ; } } } [SEP]
[CLS] void nlf _ up _ forward _ cpu ( const int n , const float * filters , const int channel , const int height , const int width , const int wsize , float * top _ data ) { for ( int index = 0 ; index < n ; index + + ) { int step = height * width ; int base = index * step ; int fbase = index / channel * wsize * step ; for ( int row = height - 1 ; row > = 0 ; row -- ) { for ( int col = width - 1 ; col > = 0 ; col -- ) { float temp = 0 ; int r = row ; int c = col ; int shift = 0 * step + row * width + col ; temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; r = row + 1 ; c = col ; shift = 1 * step + row * width + col ; if ( r < height ) temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp + = top _ data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row + 1 ; c = col - 1 ; shift = 2 * step + row * width + col ; if ( r < height & & c > = 0 ) temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp + = top _ data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row + 1 ; c = col + 1 ; shift = 3 * step + row * width + col ; if ( r < height & & c < width ) temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp + = top _ data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row ; c = col + 1 ; shift = 4 * step + row * width + col ; if ( c < width ) temp + = top _ data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp + = top _ data [ base + row * width + col ] * filters [ fbase + shift ] ; top _ data [ base + row * width + col ] = temp ; } } } } [SEP]