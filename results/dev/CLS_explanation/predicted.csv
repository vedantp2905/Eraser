sentence	labels
void CDFfunction ( float * median , float * stdvLogNormalFrame , float * MeanLogNormalFrame , unsigned char * currentFrame , int pixelsPerFrame ) { int pixel ; for ( pixel = 0 ; pixel < pixelsPerFrame ; pixel + + ) { float newvalue ; float x = currentFrame [ pixel ] ; newvalue = - ( ( log ( x ) - median [ pixel ] ) - MeanLogNormalFrame [ pixel ] ) / ( sqrt ( 2.0 ) * stdvLogNormalFrame [ pixel ] ) ; float summ = 0.5f + 0.5f * erf ( newvalue ) ; if ( summ > = 0.3 ) { currentFrame [ pixel ] = ( unsigned char ) 255 ; } else { currentFrame [ pixel ] = ( unsigned char ) 0 ; } } }	1
void mul ( float * M , float * N , float * K , float height _ M , float width _ N , float width _ M ) { for ( int i = 0 ; i < height _ M ; i + + ) { for ( int j = 0 ; j < width _ N ; j + + ) { float sum = 0 ; for ( int k = 0 ; k < width _ M ; k + + ) { float a = M [ i * ( int ) width _ M + k ] ; float b = N [ k * ( int ) width _ N + j ] ; sum + = a * b ; } K [ i * ( int ) width _ N + j ] = sum ; } } }	0
void softmax _ x _ ent _ cpu ( int n , float * pred , float * truth , float * delta , float * error ) { int i ; for ( i = 0 ; i < n ; + + i ) { float t = truth [ i ] ; float p = pred [ i ] ; error [ i ] = ( t ) ? - log ( p ) : 0 ; delta [ i ] = t - p ; } }	1
void normalize _ img ( double * image , long int image _ size , int bands ) { long int i , j ; long int row ; double * D = ( double * ) calloc ( image _ size , sizeof ( double ) ) ; for ( i = 0 ; i < image _ size * bands ; i + + ) { D [ i % image _ size ] + = image [ i ] ; } for ( i = 0 ; i < image _ size ; i + + ) { D [ i ] = powf ( D [ i ] + 1.0e-16 , -1 ) ; } for ( i = 0 ; i < bands ; i + + ) { row = i * image _ size ; for ( j = 0 ; j < image _ size ; j + + ) { image [ row + j ] = image [ row + j ] * D [ j ] ; } } free ( D ) ; }	1
void permuteData _ cpu ( const float * input , float * output , int num , int devideNum , int featureSize , int priorNum , int batchSize ) { for ( int tid = 0 ; tid < num ; tid + + ) { int numPerbatch = num * devideNum * priorNum ; for ( int s = 0 ; s < batchSize ; s + + ) { for ( int i = 0 ; i < priorNum ; i + + ) { for ( int j = 0 ; j < devideNum ; j + + ) { output [ s * numPerbatch + tid * priorNum * devideNum + i * devideNum + j ] = input [ s * numPerbatch + ( i * devideNum * featureSize ) + ( j * featureSize ) + tid ] ; } } } } }	1
void cpuSimpleCorrelator ( float * xi , float * xq , float * sr , float * si , int sLength , float * L , int uLength ) { for ( int u = 0 ; u < uLength ; u + + ) { float real = 0 ; float imag = 0 ; float a , b , c , d ; for ( int n = u ; n < u + sLength ; n + + ) { a = xi [ n ] ; b = xq [ n ] ; c = sr [ n - u ] ; d = si [ n - u ] * ( -1 ) ; real + = ( a * c ) - ( b * d ) ; imag + = ( a * d ) + ( b * c ) ; } L [ u ] = sqrt ( real * real + imag * imag ) ; } }	1
void convertKinectDisparityToRegularDisparity _ cpu ( float * d _ regularDisparity , int d _ regularDisparityPitch , const float * d _ KinectDisparity , int d _ KinectDisparityPitch , int width , int height ) { for ( int x = 0 ; x < width ; x + + ) { for ( int y = 0 ; y < height ; y + + ) { float d _ in = * ( ( float * ) ( ( char * ) d _ KinectDisparity + y * d _ KinectDisparityPitch ) + x ) ; float d _ out = ( d _ in = = 0.0f ) ? 1 : - d _ in ; * ( ( float * ) ( ( char * ) d _ regularDisparity + y * d _ regularDisparityPitch ) + x ) = d _ out ; } } }	1
void runFilterCpu ( float * I , float * Q , int samplesLength , float * filter , int filterLength , float * filtered _ I , float * filtered _ Q , int convLength ) { for ( int sampleIndex = 0 ; sampleIndex < convLength ; sampleIndex + + ) { int index ; float sumI , sumQ ; sumI = 0 ; sumQ = 0 ; for ( int j = sampleIndex - filterLength + 1 ; j < = sampleIndex ; j + + ) { index = sampleIndex - j ; if ( ( j < samplesLength ) & & ( j > = 0 ) ) { sumI + = filter [ index ] * I [ j ] ; sumQ + = filter [ index ] * Q [ j ] ; } } filtered _ I [ sampleIndex ] = sumI ; filtered _ Q [ sampleIndex ] = sumQ ; } }	1
