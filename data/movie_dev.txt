void CDFfunction ( float * median , float * stdvLogNormalFrame , float * MeanLogNormalFrame , unsigned char * currentFrame , int pixelsPerFrame ) { int pixel ; for ( pixel = 0 ; pixel < pixelsPerFrame ; pixel ++ ) { float newvalue ; float x = currentFrame [ pixel ] ; newvalue = - ( ( log ( x ) - median [ pixel ] ) - MeanLogNormalFrame [ pixel ] ) / ( sqrt ( 2.0 ) * stdvLogNormalFrame [ pixel ] ) ; float summ = 0.5f + 0.5f * erf ( newvalue ) ; if ( summ >= 0.3 ) { currentFrame [ pixel ] = ( unsigned char ) 255 ; } else { currentFrame [ pixel ] = ( unsigned char ) 0 ; } } }
void mul ( float * M , float * N , float * K , float height_M , float width_N , float width_M ) { for ( int i = 0 ; i < height_M ; i ++ ) { for ( int j = 0 ; j < width_N ; j ++ ) { float sum = 0 ; for ( int k = 0 ; k < width_M ; k ++ ) { float a = M [ i * ( int ) width_M + k ] ; float b = N [ k * ( int ) width_N + j ] ; sum += a * b ; } K [ i * ( int ) width_N + j ] = sum ; } } }
void softmax_x_ent_cpu ( int n , float * pred , float * truth , float * delta , float * error ) { int i ; for ( i = 0 ; i < n ; ++ i ) { float t = truth [ i ] ; float p = pred [ i ] ; error [ i ] = ( t ) ? - log ( p ) : 0 ; delta [ i ] = t - p ; } }
void normalize_img ( double * image , long int image_size , int bands ) { long int i , j ; long int row ; double * D = ( double * ) calloc ( image_size , sizeof ( double ) ) ; for ( i = 0 ; i < image_size * bands ; i ++ ) { D [ i % image_size ] += image [ i ] ; } for ( i = 0 ; i < image_size ; i ++ ) { D [ i ] = powf ( D [ i ] + 1.0e-16 , -1 ) ; } for ( i = 0 ; i < bands ; i ++ ) { row = i * image_size ; for ( j = 0 ; j < image_size ; j ++ ) { image [ row + j ] = image [ row + j ] * D [ j ] ; } } free ( D ) ; }
void permuteData_cpu ( const float * input , float * output , int num , int devideNum , int featureSize , int priorNum , int batchSize ) { for ( int tid = 0 ; tid < num ; tid ++ ) { int numPerbatch = num * devideNum * priorNum ; for ( int s = 0 ; s < batchSize ; s ++ ) { for ( int i = 0 ; i < priorNum ; i ++ ) { for ( int j = 0 ; j < devideNum ; j ++ ) { output [ s * numPerbatch + tid * priorNum * devideNum + i * devideNum + j ] = input [ s * numPerbatch + ( i * devideNum * featureSize ) + ( j * featureSize ) + tid ] ; } } } } }
void cpuSimpleCorrelator ( float * xi , float * xq , float * sr , float * si , int sLength , float * L , int uLength ) { for ( int u = 0 ; u < uLength ; u ++ ) { float real = 0 ; float imag = 0 ; float a , b , c , d ; for ( int n = u ; n < u + sLength ; n ++ ) { a = xi [ n ] ; b = xq [ n ] ; c = sr [ n - u ] ; d = si [ n - u ] * ( -1 ) ; real += ( a * c ) - ( b * d ) ; imag += ( a * d ) + ( b * c ) ; } L [ u ] = sqrt ( real * real + imag * imag ) ; } }
void convertKinectDisparityToRegularDisparity_cpu ( float * d_regularDisparity , int d_regularDisparityPitch , const float * d_KinectDisparity , int d_KinectDisparityPitch , int width , int height ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { float d_in = * ( ( float * ) ( ( char * ) d_KinectDisparity + y * d_KinectDisparityPitch ) + x ) ; float d_out = ( d_in == 0.0f ) ? 1 : - d_in ; * ( ( float * ) ( ( char * ) d_regularDisparity + y * d_regularDisparityPitch ) + x ) = d_out ; } } }
void runFilterCpu ( float * I , float * Q , int samplesLength , float * filter , int filterLength , float * filtered_I , float * filtered_Q , int convLength ) { for ( int sampleIndex = 0 ; sampleIndex < convLength ; sampleIndex ++ ) { int index ; float sumI , sumQ ; sumI = 0 ; sumQ = 0 ; for ( int j = sampleIndex - filterLength + 1 ; j <= sampleIndex ; j ++ ) { index = sampleIndex - j ; if ( ( j < samplesLength ) && ( j >= 0 ) ) { sumI += filter [ index ] * I [ j ] ; sumQ += filter [ index ] * Q [ j ] ; } } filtered_I [ sampleIndex ] = sumI ; filtered_Q [ sampleIndex ] = sumQ ; } }